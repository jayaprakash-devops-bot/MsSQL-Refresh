
---
- name: Ensure restore script available
  ansible.builtin.assert:
    that:
      - restore_script is defined
      - restore_script | trim != ''
    fail_msg: "Restore script is missing. Ensure restore_gen completed successfully."

- name: Define destination connection facts
  ansible.builtin.set_fact:
    dest_primary_instance: "{{ refresh_context.target.primary_replica | default(dest_instance) }}"
    dest_listener_endpoint: "{{ refresh_context.target.listener | default('') }}"

- name: Check destination database existence
  community.general.mssql_script:
    login_host: "{{ dest_primary_instance }}"
    login_user: "{{ sql_usr }}"
    login_password: "{{ sql_pwd }}"
    script: "{{ lookup('template', 'sql/check_database_exists.sql.j2') }}"
    params:
      database_name: "{{ dest_database }}"
    output: dict
  delegate_to: localhost
  register: dest_db_exists_query
  no_log: true

- name: Interpret database existence
  ansible.builtin.set_fact:
    dest_db_exists: "{{ (dest_db_exists_query.query_results_dict | json_query('[0][0][0].exists_flag') | default(0, true) | int) == 1 }}"

- name: Abort when migrate requested but destination already present
  ansible.builtin.fail:
    msg: "Destination database {{ dest_database }} already exists on {{ dest_primary_instance }} and refreshonly flag is false."
  when:
    - dest_db_exists
    - not (refreshonly | bool)

- name: Capture destination permissions prior to refresh
  when:
    - dest_db_exists
    - refreshonly | bool
  block:
    - name: Query destination permissions script
      community.general.mssql_script:
        login_host: "{{ dest_primary_instance }}"
        login_user: "{{ sql_usr }}"
        login_password: "{{ sql_pwd }}"
        name: "{{ dest_database }}"
        script: "{{ lookup('template', 'roles/dest_refresh/templates/script_perms.sql') }}"
        output: dict
      delegate_to: localhost
      register: dest_permissions_raw
      no_log: true

    - name: Persist destination permissions snapshot
      ansible.builtin.copy:
        content: "{{ dest_permissions_raw.query_results_dict | json_query('[0][0]') | default([], true) | map(attribute='query') | list | join('
') }}"
        dest: "/tmp/{{ tower_job_id }}_dest_perms.sql"
      delegate_to: localhost

- name: Remove database from AG when required
  when: refresh_context.actions.remove_dest_from_ag | default(false)
  community.general.mssql_script:
    login_host: "{{ dest_primary_instance }}"
    login_user: "{{ sql_usr }}"
    login_password: "{{ sql_pwd }}"
    script: "{{ lookup('template', 'sql/remove_database_from_ag.sql.j2') }}"
    vars:
      ag_name: "{{ refresh_context.target.ag_name }}"
      database_name: "{{ dest_database }}"
  delegate_to: localhost
  no_log: true

- name: Execute generated restore script on destination primary
  community.general.mssql_script:
    login_host: "{{ dest_primary_instance }}"
    login_user: "{{ sql_usr }}"
    login_password: "{{ sql_pwd }}"
    script: "{{ restore_script }}"
  delegate_to: localhost
  register: dest_restore_execution
  no_log: true

- name: Log restore completion
  ansible.builtin.set_fact:
    log_msg: "{{ log_msg ~ '
' ~ ('%Y-%m-%d %H:%M:%S' | strftime) ~ ' Restore executed on ' ~ dest_primary_instance }}"

- name: Validate permission script availability
  ansible.builtin.stat:
    path: "{{ refresh_context.source.permission_script | default('') }}"
  delegate_to: localhost
  register: src_perm_stat
  when: refresh_context.source.permission_script is defined

- name: Apply source permission script to destination
  when:
    - refresh_context.source.permission_script is defined
    - src_perm_stat.stat.exists
    - not restore_type is search('No Recovery')
  community.general.mssql_script:
    login_host: "{{ dest_primary_instance }}"
    login_user: "{{ sql_usr }}"
    login_password: "{{ sql_pwd }}"
    script: "{{ lookup('file', refresh_context.source.permission_script) }}"
  delegate_to: localhost
  no_log: true

- name: Apply source login script on destination primary
  when:
    - refresh_context.source.login_script is defined
    - (refresh_context.source.login_script | length) > 0
    - not restore_type is search('No Recovery')
  community.general.mssql_script:
    login_host: "{{ dest_primary_instance }}"
    login_user: "{{ sql_usr }}"
    login_password: "{{ sql_pwd }}"
    script: "{{ lookup('file', refresh_context.source.login_script) }}"
  delegate_to: localhost
  no_log: true
  ignore_errors: true

- name: Apply login script via listener when available
  when:
    - refresh_context.source.login_script is defined
    - (refresh_context.source.login_script | length) > 0
    - dest_listener_endpoint | length > 0
    - not restore_type is search('No Recovery')
  community.general.mssql_script:
    login_host: "{{ dest_listener_endpoint }}"
    login_user: "{{ sql_usr }}"
    login_password: "{{ sql_pwd }}"
    script: "{{ lookup('file', refresh_context.source.login_script) }}"
  delegate_to: localhost
  no_log: true
  ignore_errors: true

- name: Run sp_fix_users to resolve orphaned accounts
  community.general.mssql_script:
    login_host: "{{ dest_primary_instance }}"
    login_user: "{{ sql_usr }}"
    login_password: "{{ sql_pwd }}"
    script: "USE [{{ dest_database }}]; EXEC master.dbo.sp_fix_users;"
  delegate_to: localhost
  no_log: true
  ignore_errors: true
  when:
    - not restore_type is search('No Recovery')

- name: Update refresh context for destination state
  ansible.builtin.set_fact:
    refresh_context: "{{ refresh_context | combine({'target': (refresh_context.target | default({})) | combine({'restored_at': ('%Y-%m-%d %H:%M:%S' | strftime), 'restore_result': dest_restore_execution.query_results | default([])}, recursive=True)}, recursive=True) }}"
    log_msg: "{{ log_msg ~ '
' ~ ('%Y-%m-%d %H:%M:%S' | strftime) ~ ' Destination restore workflow completed.' }}"

- name: Bundle generated scripts for mail attachment
  ansible.builtin.shell: |
    Compress-Archive -Path /tmp/{{ tower_job_id }}*.* -CompressionLevel Optimal -DestinationPath /tmp/{{ tower_job_id }}_all_scripts.zip -Force
  args:
    executable: pwsh
  delegate_to: localhost
  register: dest_zip_result
  changed_when: true

- name: Track archive path in refresh context
  ansible.builtin.set_fact:
    refresh_context: "{{ refresh_context | combine({'artifacts': {'bundle': '/tmp/' ~ (tower_job_id | string) ~ '_all_scripts.zip'}}, recursive=True) }}"
    paths_attach: "{{ paths_attach | default([]) + ['/tmp/' ~ (tower_job_id | string) ~ '_all_scripts.zip'] }}"
