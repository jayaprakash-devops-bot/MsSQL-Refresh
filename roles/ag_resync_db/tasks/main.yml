---
- include_vars:
    file: vars.yml
    
- name: do initial checks and includes
  block:
    - name: retrieve cred for sql_usr
      cyberark.pas.cyberark_credential:
        api_base_url: "https://cyberarkccp"
        app_id: "Ansible_MSSQL"
        query: "safe=ET_Ansible_MSSQL;UserName=svc_sqlAvia;Address=local"
        validate_certs: no
      register: pwd  
      delegate_to: localhost
      no_log: true

    - name: set password
      set_fact:
        sql_pwd:  "{{ pwd.result.Content }}"
      no_log: true     

    - include_vars:
        file: main2.yml

    - name: verify listener name is valid
      shell: |
        # If(-not(Get-InstalledModule SQLServer -ErrorAction silentlycontinue)){
        #  Install-Module SQLServer -Confirm:$False -Force
        #  }
        $output = Invoke-Sqlcmd -Query  "SELECT [Name] AS [value] FROM sys.availability_groups WHERE name = '{{ Dest_ag_name }}'" `
        -QueryTimeout 0 -ServerInstance "{{ dest_instance }}" `
        -UserName "{{ sql_usr }}" -Password "{{ sql_pwd }}" -TrustServerCertificate  
        return $output | Select-Object -ExpandProperty value
      args:
        executable: pwsh
      delegate_to: localhost
      register: listener_verify
      no_log: true

    - name: raise error for bad listener name
      set_fact:
        log_msg: "{{ log_msg + '\n' + '%Y-%m-%d %H:%M:%S' | strftime + ' There was a issue verifying ' + dest_instance + '/' + Dest_ag_name}}"
      when:  listener_verify == ''

    - name:  
      debug: msg="raising error"   
      failed_when:  listener_verify == '' 
      when:  listener_verify == ''          

    # - name: get primary instance name    
    #   win_shell:  |
    #     $Output = Invoke-Sqlcmd -Query "{{ ag.primary_instance }}" `
    #     -QueryTimeout 0 -ServerInstance "{{ dest_instance }}" -UserName "{{ sql_usr }}" -Password "{{ sql_pwd }}"
    #     $Output | Select-Object -ExpandProperty value
    #   delegate_to: '{{ ctrl_server }}'
    #   register: primary_instance
    #   no_log: true   

    # - debug:
    #     msg: "{{ primary_instance }}"
    #     verbosity: 3    

    # - set_fact:
    #     primary_instance_name: "{{ primary_instance.stdout }}"
    #     log_msg: "{{ log_msg + '\n' + '%Y-%m-%d %H:%M:%S' | strftime + ' primary replica found: ' + primary_instance.stdout}}"
    #   no_log: true

    # - name: check for contained availability group    
    #   win_shell:  |
    #     $Output = Invoke-Sqlcmd -Query "{{ ag.contained }}" `
    #     -QueryTimeout 0 -ServerInstance "{{ dest_instance }}" -UserName "{{ sql_usr }}" -Password "{{ sql_pwd }}"
    #     $Output | Select-Object -ExpandProperty value
    #   delegate_to: '{{ ctrl_server }}'
    #   register: check_contained
    #   no_log: true   

    # - set_fact:
    #     isContained: "{{ check_contained.stdout | trim}}"
    #     log_msg: "{{ log_msg + '\n' + '%Y-%m-%d %H:%M:%S' | strftime + ' is contained availability group: ' + check_contained.stdout}}"
    #   no_log: true

    - name: check for contained availability group    
      win_shell:  |
        $Output = Invoke-Sqlcmd -Query "{{ ag.contained }}" -QueryTimeout 0 -ServerInstance "{{ dest_instance }}" -UserName "{{ sql_usr }}" -Password "{{ sql_pwd }}"
        $Output | Select-Object -ExpandProperty value
      delegate_to: '{{ ctrl_server }}'
      register: check_contained
      no_log: true

    - debug:
        msg: "{{ check_contained }}"
        verbosity: 3

    - name: set fact for contained AG
      set_fact:
        isContained: "{{ check_contained.stdout | trim }}"
        log_msg: "{{ log_msg + '\n' + '%Y-%m-%d %H:%M:%S' | strftime + ' is contained availability group: ' + check_contained.stdout }}"
      ignore_errors: true

    - debug:
        var: isContained

    - include_vars:
        file: main.yml

    - name: verify database(s) exists 
      shell: |
        $dblist = "{{db_list}}"
        $dblist.Split(',') | ForEach-Object {
        Invoke-Sqlcmd -Query "SELECT IIF (EXISTS (SELECT 1 FROM master.dbo.sysdatabases WHERE [name] = '$_'), '$_,true','$_,false')" `
        -QueryTimeout 0 -ServerInstance "{{ Primary_dest_node }}" `
        -UserName "{{ sql_usr }}" -Password "{{ sql_pwd }}" -TrustServerCertificate | Select-Object -ExpandProperty Column1}
      args:
        executable: pwsh
      delegate_to: localhost            
      register: verify_db_out_7
      no_log: true 
      
    - debug: 
        var: verify_db_out_7 
        verbosity: 3

    - name: initialize db_dict
      set_fact:
        db_dict: {}

    - name: populate db_dictionary 
      set_fact: 
        db_dict: "{{ db_dict | combine({item.split(',')[0] | trim: item.split(',')[1] | trim} ) }}"
      loop: "{{ verify_db_out_7.stdout_lines }}"  
      ignore_errors: true  

    - debug:
        msg: "{{ db_dict }}"
        verbosity: 3  
      ignore_errors: true

    - name: remove databases from list that do not exsist
      set_fact:
          db_list2: "{{ db_list2 }}{{ (index > 0)|ternary(',','') }}{{ item.key }}"
      when: item.value == 'true'
      loop: "{{ db_dict|dict2items }}"
      ignore_errors: true 
      loop_control: 
        index_var: index

    - debug:
        msg: "{{ db_list2 }}" 
        verbosity: 3  
      ignore_errors: true                   

    - name: only process databases that exsit
      set_fact: 
        log_msg: "{{ log_msg + '\n'  + '%Y-%m-%d %H:%M:%S' | strftime + ' Warning database ' + item.key + ' not found and will not be processed!' }}"     
      loop: "{{ db_dict | dict2items }}"
      ignore_errors: true  
      when: item.value  != "true"

    - name: remove database(s) from ag if already joined
      shell: |
          $dblist = "{{db_list2}}"
          $dblist.Split(',') | ForEach-Object {
            Invoke-Sqlcmd -Query "BEGIN TRY ALTER AVAILABILITY GROUP [{{Dest_ag_name}}] REMOVE DATABASE [$_]; END TRY BEGIN CATCH END CATCH" `
            -QueryTimeout 0 -ServerInstance "{{ Primary_dest_node }}" `
            -UserName "{{ sql_usr }}" `
            -Password "{{ sql_pwd }}" `
            -TrustServerCertificate
          }
      args:
        executable: pwsh
      delegate_to: localhost
      register: out_remove
      when: skip_replica == ""   
      ignore_errors: true
      no_log: true

    - debug: 
        msg: "{{ out_remove.delta }}"
        verbosity: 3 
      when: skip_replica == "" 

    # - name: ensure system proc restore_gene exists
    #   include_role:
    #     name: tsql
    #     tasks_from: ensure_system_procs.yml
    #   vars:
    #     instance: "{{ dest_instance  }}"
    #     exec_sql_user: true

    # - name: get secondary instances
    #   shell:  |
    #     $Output = Invoke-Sqlcmd -Query  "{{ ag.secondary_instances }}" `
    #     -QueryTimeout 0 -ServerInstance "{{ dest_instance }}" -UserName "{{ sql_usr }}" -Password "{{ sql_pwd }}" -TrustServerCertificate
    #     $Output | Where-Object Value -ne "{{ skip_replica }}"  | Select-Object -ExpandProperty Value
    #   args:
    #     executable: pwsh
    #   delegate_to: localhost
    #   register: secondary_instances_out  
    #   no_log: true

    # - debug:
    #     msg: "{{ now() }}"
    #     verbosity: 3           

    # - set_fact:
    #     secondary_instances: "{{ secondary_instances }}{{ (index > 0)|ternary(',','') }}{{ item }}"
    #     log_msg: "{{ log_msg + '\n' + '%Y-%m-%d %H:%M:%S' | strftime + ' secondary replica found: ' + item}}"
    #   loop: "{{ secondary_instances_out.stdout_lines }}"
    #   loop_control:
    #     index_var: index
    #   no_log: true

    - set_fact:
        log_msg: "{{ log_msg + '\n' + '%Y-%m-%d %H:%M:%S' | strftime + ' skipping secondary replica: ' + skip_replica}}"
      when: skip_replica|length>0

    - debug:
        msg: "{{ Secondary_dest_node }}"
        #verbosity: 3

    # - meta: end_play
    #   when: skip_replica|length>0  
      
    - name: get backup dir
      shell:  |
        $Output = Invoke-Sqlcmd -Query  "{{ gen.get_backup_dir }}" `
        -QueryTimeout 0 -ServerInstance "{{ Primary_dest_node }}" -UserName "{{ sql_usr }}" -Password "{{ sql_pwd }}" -TrustServerCertificate
        $Output | Select-Object -ExpandProperty Value
      args:
        executable: pwsh
      delegate_to: localhost
      register: backup_location_out          
      no_log: true
      ignore_errors: true
      # when: not isContained

    - debug:
        msg: "{{backup_location_out}}"
        verbosity: 3  
      ignore_errors: true  

    - set_fact:
        backup_location: "{{ backup_location_out.stdout }}"
        log_msg: "{{ log_msg + '\n' + '%Y-%m-%d %H:%M:%S' | strftime + ' backup location: ' + backup_location_out.stdout}}"
      when: backup_location_out is defined
      ignore_errors: true

    - name: ensure databases are in full recovery mode
      shell: |
        $dblist = "{{db_list2}}"
        $dblist.Split(',') | ForEach-Object {
          $Output = Invoke-Sqlcmd -Query  "{{ db.recovery.set_full }}" `
          -QueryTimeout 0 -TrustServerCertificate -ServerInstance "{{ Primary_dest_node }}" -UserName "{{ sql_usr }}" -Password "{{ sql_pwd }}"} 
          return $Output
      args:
        executable: pwsh
      delegate_to: localhost
      register: set_fullmode
      no_log: true

    - debug:
        msg: "{{set_fullmode}}"
        verbosity: 3

    - name: get txnlog backup job_id
      shell: |
        $dblist = "{{db_list2}}"
        $dblist.Split(',') | ForEach-Object {
          $Output = Invoke-Sqlcmd -Query  "{{ ag.get_txnlog_job_id }}" `
          -QueryTimeout 0 -TrustServerCertificate -ServerInstance "{{ Primary_dest_node }}" -UserName "{{ sql_usr }}" -Password "{{ sql_pwd }}"} 
          return $Output | Select-Object -ExpandProperty Value
      args:
        executable: pwsh
      delegate_to: localhost
      register: get_txnlogjob_id
      no_log: true
      when: not isContained

    - debug:
        msg: "{{get_txnlogjob_id}}"
        verbosity: 3

    - set_fact:
        txnlog_job_id: "{{ get_txnlogjob_id.stdout }}"
        log_msg: "{{ log_msg + '\n' + '%Y-%m-%d %H:%M:%S' | strftime + ' transaction log job_id to be disabled: ' + get_txnlogjob_id.stdout}}"
      when: not isContained  

    - name:  disable txnlog backups
      shell: |
          $Output = Invoke-Sqlcmd -Query  "EXEC msdb.dbo.sp_update_job @job_id='{{ txnlog_job_id }}',@enabled = 0" `
          -QueryTimeout 0 -TrustServerCertificate -ServerInstance "{{ Primary_dest_node }}" -UserName "{{ sql_usr }}" -Password "{{ sql_pwd }}"
      args:
        executable: pwsh
      delegate_to: localhost
      no_log: true
      when: not isContained

    - name: get sql version
      shell: |
          $Output = Invoke-Sqlcmd -Query  "SELECT SERVERPROPERTY('ProductMajorVersion') as Value" `
          -QueryTimeout 0 -TrustServerCertificate -ServerInstance "{{ Primary_dest_node }}" -UserName "{{ sql_usr }}" -Password "{{ sql_pwd }}" 
          $Output | Select-Object -Expandproperty Value
      args:
        executable: pwsh
      delegate_to: localhost
      register: version_out
      no_log: true
      #when: not isContained

    - debug:
        msg: "{{version_out}}"
        verbosity: 3

    - set_fact: 
        log_msg: "{{ log_msg + '\n' + '%Y-%m-%d %H:%M:%S' | strftime + ' Begin full backup of database(s) '}}"
      when: not isContained

    - debug:
        msg: "{{ isContained }}"

    - set_fact: 
        log_msg: "{{ log_msg + '\n\n' + '%Y-%m-%d %H:%M:%S' | strftime + ' Skipping full backup of database(s) ' + db_list2 + ' because they are in a contained availability group  '}}"
      when: isContained | bool
    
    - debug:
        msg: "{{scalar_return}}"
        verbosity: 3

    - name: Deub var "{{ Primary_dest_node }}"
      debug:
        msg: "{{ Primary_dest_node }}"
        verbosity: 3
      when: 
        - version_out.stdout | int > 12
        
    - name: take full backup of database(s) when version is 2016 and greater"
      shell: |
        $dblist = "{{db_list2}}"
        $dblist.Split(',') | ForEach-Object -parallel {
        $qry = "{{ db.backup.full_native_16_17 }}"
        Invoke-Sqlcmd -Query $qry -QueryTimeout 0 -TrustServerCertificate -ServerInstance "{{ Primary_dest_node }}" `
        -UserName "{{ sql_usr }}" -Password "{{ sql_pwd }}" } -ThrottleLimit 3 
      args:
        executable: pwsh
      delegate_to: localhost 
      register: output_bk_16
      no_log: true
      when: 
        - version_out.stdout | int > 12
        #- not isContained #need to take a full backup when a database is restored before joining to AG

    - set_fact: 
        log_msg: "{{ log_msg + '\n' + '%Y-%m-%d %H:%M:%S' | strftime + ' Elapsed time to backup databaes(s) is ' + output_bk_16.delta}}"            
      when: 
        - version_out.stdout | int > 12 
        - output_bk_16 is defined      

    - name: take full backup of database(s) when version is 2014 and lesser"
      shell: |
        $dblist = "{{db_list2}}"
        $dblist.Split(',') | ForEach-Object -parallel {
        $qry = "{{ db.backup.full_native_14 }}"
        Invoke-Sqlcmd -Query $qry -QueryTimeout 0 -TrustServerCertificate -ServerInstance "{{ Primary_dest_node }}" `
        -UserName "{{ sql_usr }}" -Password "{{ sql_pwd }}"} -ThrottleLimit 3
      args:
        executable: pwsh
      delegate_to: localhost 
      register: output_bk_14
      no_log: true
      when: 
        - version_out.stdout | int <= 12
        - not isContained

    - set_fact: 
        log_msg: "{{ log_msg + '\n' + '%Y-%m-%d %H:%M:%S' | strftime + ' Elapsed time to backup database(s) is ' + output_bk_14.delta}}"            
      when: 
        - version_out.stdout | int <= 12
        - output_bk_14 is defined
        - not isContained         

    - set_fact: 
        log_msg: "{{ log_msg + '\n' + '%Y-%m-%d %H:%M:%S' | strftime + ' Begin transaction log backup of database(s) '}}"
      when: not isContained               

    - name: take native tlog backup of database(s)"
      shell: |
        $dblist = "{{db_list2}}"
        $dblist.Split(',') | ForEach-Object -parallel {
        $qry = "{{ db.backup.txn_native }}"
        Invoke-Sqlcmd -Query $qry -QueryTimeout 0 -ServerInstance "{{ Primary_dest_node }}" `
        -TrustServerCertificate -UserName "{{ sql_usr }}" -Password "{{ sql_pwd }}"} 
      args:
        executable: pwsh
      delegate_to: localhost 
      register: output_txn          
      when: not isContained
      no_log: true

    - set_fact: 
        log_msg: "{{ log_msg + '\n' + '%Y-%m-%d %H:%M:%S' | strftime + ' Elapsed time to backup txn log(s) is ' + output_txn.delta}}"            
      when: 
        - output_txn is defined
        - not isContained

    - name: generate restore scripts 
      shell: |
        [string]$output
        "{{db_list2}}".split(',') | ForEach-Object {
            $qry = "exec sp_RestoreGene @Database='$_',@RestoreScriptOnly=1,@WithReplace=1,@WithRecovery=0" 
            $out =  Invoke-Sqlcmd  -Query "$qry" -QueryTimeout 0 -ServerInstance "{{ Primary_dest_node }}" -UserName "{{ sql_usr}}" -Password "{{ sql_pwd }}" -TrustServerCertificate
            $output += ($out | Select-Object -ExpandProperty "Value") + "|"
            }
            #$output = $output -replace ".$" 
            return $output
      args:
        executable: pwsh
      delegate_to: localhost 
      register: restores
      when: not isContained
      no_log: true
      
    - set_fact:
        restore_scripts: "{{ restores.stdout }}"
      when: not isContained

    - debug:
        msg: "{{restores.stdout}}"
        verbosity: 3
      when: not isContained

    - name: drop database(s) on destinations
      shell: |
        $dblist = "{{db_list2}}"
        $instances = "{{Secondary_dest_node}}"
        foreach($i in $instances.split(',')){
          $dblist.split(',') | ForEach-Object  {
              $qry = "BEGIN TRY DROP DATABASE [$_] END TRY BEGIN CATCH END CATCH"
              Invoke-Sqlcmd -Query $qry -QueryTimeout 0 -TrustServerCertificate  -ServerInstance "$i" `
              -UserName "{{ sql_usr }}" -Password "{{ sql_pwd }}"                
            }
          }          
      args:
        executable: pwsh
      delegate_to: localhost
      register: drop_dest_dbs_out
      ignore_errors: true
      no_log: true

    - debug: 
        var: drop_dest_dbs_out
        verbosity: 3

    - name: removed from secondary replica (when skipping other replica's)
      shell: |
        $dblist = "{{db_list2}}"
        $instances = "{{Secondary_dest_node}}"
        foreach($i in $instances.split(',')){
          $dblist.split(',') | ForEach-Object  {
              $qry = "BEGIN TRY ALTER DATABASE [$_] SET HADR OFF END TRY BEGIN CATCH END CATCH"
              Invoke-Sqlcmd -Query $qry -QueryTimeout 0 -TrustServerCertificate -ServerInstance "$i" `
              -UserName "{{ sql_usr }}" -Password "{{ sql_pwd }}"                  
            }
          }          
      args:
        executable: pwsh
      delegate_to: localhost
      when: skip_replica != ""   
      no_log: true   

    - set_fact: 
        log_msg: "{{ log_msg + '\n' + '%Y-%m-%d %H:%M:%S' | strftime + ' Begin Restoring to Secondary(s) '}}"
      when: not isContained

    - debug:
        var: Secondary_dest_node
        verbosity: 3
      when: not isContained
    - debug:
        var: restore_scripts      
        verbosity: 3
      when: not isContained

    - name: restore database(s)
      shell: |
        $qrys = "{{restore_scripts}}" 
        $qrys = $qrys.Substring(0,$qrys.Length-1)           
        $instances = "{{Secondary_dest_node}}"
        foreach($i in $instances.split(',')){
        $qrys.split('|') | ForEach-Object -parallel {
          $output += Invoke-sqlcmd -TrustServerCertificate -ServerInstance "$using:i" -Query "$_" -QueryTimeout 0 `
          -UserName "{{ sql_usr }}" -Password "{{ sql_pwd }}" 
          }
        }
        return $output
      args:
        executable: pwsh
      delegate_to: localhost 
      register: restore_db_out
      ignore_errors: true
      no_log: true
      when: not isContained

    - set_fact: 
        log_msg: "{{ log_msg + '\n' + '%Y-%m-%d %H:%M:%S' | strftime + ' Elapsed time to restoring to Secondary(s) is ' + restore_db_out.delta}}"            
      when: not isContained   

    - debug: 
        msg: "{{ restore_db_out }}"  
        verbosity: 3
      when: not isContained

    - name: verify and join database(s) to ag when not contained
      shell: |
        $dblist = "{{db_list2}}"
        $dblist.Split(',') | ForEach-Object  {
        Invoke-Sqlcmd -Query "ALTER AVAILABILITY GROUP {{ Dest_ag_name }} ADD DATABASE [$_]" -QueryTimeout 0 -ServerInstance "{{ Primary_dest_node }}" `
        -UserName "{{ sql_usr }}" -Password "{{ sql_pwd }}" -TrustServerCertificate}
      args:
        executable: pwsh
      ignore_errors: true  
      delegate_to: localhost
      when: not isContained
      no_log: true

    - name: verify and join database(s) to ag when contained
      shell: |
        $dblist = "{{db_list2}}"
        $dblist.Split(',') | ForEach-Object  {
        Invoke-Sqlcmd -Query "ALTER AVAILABILITY GROUP {{ Dest_ag_name }} ADD DATABASE [$_]" -QueryTimeout 0 -ServerInstance "{{ Primary_dest_node }}" `
        -UserName "{{ sql_usr }}" -Password "{{ sql_pwd }}" -TrustServerCertificate}
      args:
        executable: pwsh
      ignore_errors: true  
      delegate_to: localhost
      when: isContained
      no_log: true
      
    - name: applying Destination Users Script after adding db to contained AG
      shell: |
        $out = Invoke-sqlcmd  -InputFile "/tmp/{{tower_job_id}}_dest_perms.sql" -ServerInstance '{{ Primary_dest_node }}' -QueryTimeout 0 -TrustServerCertificate -UserName "{{ sql_usr }}" -Password "{{ sql_pwd }}" -Verbose 4>&1 | Out-String
        return $out
      args:
        executable: pwsh
      delegate_to: localhost        
      register: create_usrs_out
      ignore_errors: true
      no_log: true
      when:
        - refreshonly | bool
        - isContained     

    - name: join secondary database(s) to ag
      shell: |
        $dblist = "{{db_list2}}"
        $instances = "{{Secondary_dest_node}}"
        foreach($i in $instances.split(',')){
        $dblist.Split(',') | ForEach-Object  {
        Invoke-Sqlcmd -Query "ALTER DATABASE [$_] SET HADR AVAILABILITY GROUP = {{ Dest_ag_name }}" -QueryTimeout 0 -TrustServerCertificate -ServerInstance "$i" `
        -UserName "{{ sql_usr }}" -Password "{{ sql_pwd }}"
          }
        }
      args:
        executable: pwsh
      ignore_errors: true  
      delegate_to: localhost
      when: not isContained
      no_log: true

    - set_fact: 
        log_msg: "{{ log_msg + '\n' + '%Y-%m-%d %H:%M:%S' | strftime + ' Check Seeding Status by running the following query: ' + ag.check_status}}"
      when: isContained     

    - set_fact: 
        log_msg: "{{ log_msg + '\n\n' + '%Y-%m-%d %H:%M:%S' | strftime + ' Process complete! '}}"

  rescue:
    - set_fact:
        log_msg:  "{{ log_msg + '\n' + '%Y-%m-%d %H:%M:%S' | strftime + ' There was a error with task: ' + ansible_failed_task.name + '\r\n'}}"
        ignore_errors: true   
        when: ansible_failed_task is defined  
    - set_fact:
        log_msg:  "{{ log_msg + '\n' + '%Y-%m-%d %H:%M:%S' | strftime + ' The error message is: ' + ansible_failed_result.msg + '\r\n'}}"
        ignore_errors: true   
    - set_fact:
        log_msg:  "{{ log_msg + '\n' + '%Y-%m-%d %H:%M:%S' | strftime + ' There was a error encountered \r\n'}}" 
  
  always:
    - name:  enable txnlog backups
      shell: |
            $Output = Invoke-Sqlcmd -Query  "EXEC msdb.dbo.sp_update_job @job_id='{{ txnlog_job_id }}',@enabled = 1" `
            -QueryTimeout 0 -ServerInstance "{{ Primary_dest_node }}" -TrustServerCertificate -UserName "{{ sql_usr }}" -Password "{{ sql_pwd }}"
            $Output | Select-Object -Expandproperty Value
      args:
        executable: pwsh
      delegate_to: localhost
      register: version_out
      no_log: true
      when: 
        - txnlog_job_id is defined

    - name: create temp file
      tempfile:
        state: file
        suffix: log
      delegate_to: localhost
      register: log_temp_out

    - name: write log to temp file     
      lineinfile:
        path: "{{ log_temp_out.path }}"
        line: "{{ log_msg }}"
      delegate_to: localhost

    - name: get local host time
      delegate_to: localhost
      shell: "date +%Y-%m-%d%H-%M-%S"
      register: tstamp

    - name: localhost time
      debug: 
        msg: "{{ tstamp }}"
        verbosity: 3

    - name: print type of notify email
      debug: 
        msg: "{{ notify_email | type_debug == 'list'}}"             

    - name: get recipients from passed list
      delegate_to: localhost
      run_once: true    
      set_fact:
          recs: "{{ notify_email|join(',') }}"
      register: email_passed_dic    
      when: "{{ notify_email | type_debug == 'list'}}" 

    - name: get recipients from string
      delegate_to: localhost
      run_once: true    
      set_fact:
          recs: "{{ notify_email }}"
      when: email_passed_dic is skipped

    - name: print recs
      debug: 
        msg: "{{ recs }}"  
        verbosity: 3

    - name: "email the results to {{notify_email}}"
      shell: |
        [string]$body = Get-Content -Path {{log_temp_out.path}} -Raw

        #$SMTPServer = "{{ smtp_server }}"
        $msg = new-object Net.Mail.MailMessage
        $msg.from = "{{ ctrl_server }}@energytransfer.com"
        #$recs = '{{ recs }}' -split ", "

        $msg.Subject = "AG Sync Database Results - Job ID {{ tower_job_id }}"
        $msg.Body = $body       

        $mailer = new-object Net.Mail.SMTPclient("{{ smtp_server }}")
        
        foreach($a in "{{ recs }}".Split(","))
        {$msg.to.Add($a)}

        $mailer.send($msg)
      args:
        executable: pwsh
      delegate_to: localhost  
      register: sendmail_out
      when: 
        - notify_email is defined  

    - name: clean up any temp files
      file:
        path: "{{ item }}"
        state: absent
      delegate_to: localhost   
      loop:
        - "{{log_temp_out.path}}"

    - name: get all temp files created
      find:
          paths: /tmp
          patterns: "{{tower_job_id}}*.*,*.sql,*.log"
      delegate_to: localhost   
      register: temp_files_to_delete
      when: isContained

    - name: clean up all temp files created
      file:
          path: "{{item.path}}" 
          state: absent
      delegate_to: localhost
      with_items: "{{temp_files_to_delete.files}}"
      when: isContained
